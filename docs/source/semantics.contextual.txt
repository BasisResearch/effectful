Syntax
======

o ∈ 𝕆, the set of operations
n ∈ ℕ, the set of names
c ∈ ℂ, the set of constants

e = v                     (Literals)
  | e₁ e₂                 (Application)
  | n                     (Variables)
  | do o e                (Operation Invocations)
  | interpreter H: e      (Effect Interpreters)
  | handler H: e          (Effect Handlers)
  | shallow H: e          (Shallow Interpreters)
  | runner H: e           (Effect Runners)
  | fix H: e              (Effect Fixing)
v = c                     (Constants)
  | λ n. e                (Abstractions)
H = { (o → λ n. e), ... } (Interpretation Literals)
C = □                     (Empty Contexts)
  | C e                   (Function Contexts)
  | v C                   (Argument Contexts)
  | do o C                (Invocation Contexts)
  | interpreter H: C      (Interpreter Contexts)
  | handler H: C          (Handler Contexts)
  | shallow H: C          (Shallow Interpreter Contexts)
  | runner H: C           (Runner Contexts)
  | fix H: C              (Fix Contexts)

Functions and Constants
=======================

[Predefined Names]

reflect, fwd ∈ 𝕆

[Handled-By Relation]

o ~ H ⇔ ∃ e, (o → λ n. e) ∈ H
o ≁ H ⇔ ¬(o ~ H)

[Interpretation Union (right-prioritizing dictionary union)]

{}                  ⨆ r = r
{(o → λ n. e), ...} ⨆ r = ({...} ⨆ r)                  if o ~ r
                          ({...} ⨆ r) ∪ {(o → λ n. e)} otherwise

[Context Interpretation]

handled(□)                = ∅
handled(C e)              = handled(C)
handled(v C)              = handled(C)
handled(do o C)           = handled(C)
handled(interpreter H: C) = H ⨆ handled(C)
handled(handler H: C)     = H ⨆ handled(C)
handled(shallow H: C)     = H ⨆ handled(C)
handled(runner H: C)      = H ⨆ handled(C)
handled(fix H: C)         = H ⨆ handled(C)

Semantics
=========

[β-reduction]

---------------------------
  C[(λ n. e) v] ⇒ C[e[n ↦ v]]

[Interpreters over Values]

----------------------
 C[interpreter H: v] ⇒ C[v]

[Interpreter Invocation]

       (o → λ n. e) ∈ H                 o ≁ handled(C₂)
-----------------------------------------------------------------
 C₁[interpreter H: C₂[do o v] ⇒ C₁[interpreter H: C₂[(λ n. e) v]]

[Shallow Interpreters over Values]

---------------------
 C[shallow H: v ⇒ v]

[Shallow Interpreter Invocation]

       (o → λ n. e) ∈ H     o ≁ handled(C₂)
---------------------------------------------------
   C₁[shallow H: C₂[do o v]] ⇒ C₁[C₂[(λ n. e) v]]

[Fix over Values]

--------------------
 C[fix H: v] ⇒ C[v]

[Fix Invocation]

           (o → λ n. e) ∈ H            o ≁ handled(C₂)
-------------------------------------------------------------------
 C₁[fix H: C₂[do o v]] ⇒ C₁[fix H: C₁[interpreter H: (λ n. e) v]]]

[Handlers over Values]

------------------------
 C[handler H: v] ⇒ C[v]

[Outermost Handlers]

 (o → λ n. e) ∈ H    o ≁ handled(C₁)    o ≁ handled(C₂)
-----------------------------------------------------------
 C₁[handler H: C₂[do o v]] ⇒ C₁[handler H: C₂[(λ n. e) v]]

[Nested Handlers]

   (o → λ n₁. e₁) ∈ H    (o → λ n₂. e₂) ∈ handled(C₁)    o ≁ handled(C₂)
-------------------------------------------------------------------------------
 C₁[handler H: C₂[do o v]]
    ⇒
 C₁[handler H: C₂[shallow {(fwd → λn₂. e₂)}: (λ n₁. e₁) v]]

[Runners over Values]

-----------------------
 C[runner H: v] ⇒ C[v]

[Outermost Runners]

 H₂ = handled(C₁), (o → λ n. e) ∈ H₁, o ≁ H₂, o ≁ handled(C₂)
--------------------------------------------------------------
 C₁[runner H₁: C₂[do o v]]
   ⇒
 C₁[runner H₁: C₂[interpreter H₂: (λ n. e) v]]

[Nested Runners]

 H₂ = handled(C₁), (o → λ n₁. e₁) ∈ H₁, o ~ H₂, o ≁ handled(C₂)
-----------------------------------------------------------------------------
 C₁[runner H₁: C₂[do o v]]
     ⇒
 C₁[runner H₁:
     C₂[fix H₂:
         shallow {(reflect → λ n₂. interpreter H₂: do o n₂)}:
             (λ n₁. e₁) v
     ]
 ]

Example Derivations
===================

[Simple Interpreter Usage]

  -----------------------------       --------------
  (o → λ n. e) ∈ {(o → λ n. e)}       o ≁ handled(□)
------------------------------------------------------ [Interpreter Invocation]
   interpreter {(o → λ n. e)}: do o c ⇒ (λ n. e) c

[Forwarding]

Assume {square, 2, 4, ()} ⊆ ℂ, get ∈ 𝕆, and rewrite rule [Square Impl]:

----------------------
 C[(square 2)] ⇒ C[4]


handler {(get → λ n₂. 2)}:
    handler {(get → λ n₁. square (do fwd n₁))}:
        do get ()
⇒ [Nested Handlers] where
  C₁=(handler {(get → λ n. 2)}: □),
  C₂=□,
  H={(get → λ n₁. (square (do fwd n₁)))},
  o=get,
  e₁=(square (do fwd n₁)),
  e₂=2
handler {(get → λ n₂. 2)}:
    handler {(get → λ n₁. square (do fwd n₁))}:
        shallow {(fwd → λn₂. 2)}:
            (λ n₁. (square (do fwd n₁))) ()
⇒ [β-reduction] where
  C=(handler {...}: handler {...}: shallow {...}: □),
  n=n₁,
  v=(),
  e=(square (do fwd n₁))
handler {(get → λ n₂. 2)}:
    handler {(get → λ n₁. square (do fwd n₁))}:
        shallow {(fwd → λn₂. 2)}:
            (square (do fwd ()))
⇒ [Shallow Interpreter Invocation] where
  C₁=(handler {...}: handler: {...}: □),
  C₂=(square □)
  n=n₂,
  o=fwd,
  e=2
handler {(get → λ n₂. 2)}:
    handler {(get → λ n₁. square (do fwd n₁))}:
        (square ((λ n₂. 2) ()))
⇒ [β-reduction] where
  C=(handler {...}: handler {...}: (square □)),
  n=n₂,
  e=2,
  v=()
handler {(get → λ n₂. 2)}:
    handler {(get → λ n₁. square (do fwd n₁))}:
        (square 2)
⇒ [Square Impl] where
  C=(handler {...}: handler {...}: □)
handler {(get → λ n₂. 2)}:
    handler {(get → λ n₁. square (do fwd n₁))}:
        4
⇒ [Handlers over Values] where
  C=(handler {...}: □),
  H={...},
  v=4
handler {(get → λ n₂. 2)}:
    4
⇒ [Handlers over Values] where
  C=□,
  H={...},
  v=4
4
