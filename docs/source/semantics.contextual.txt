Syntax
======

o ∈ 𝕆, the set of operations
n ∈ ℕ, the set of names
c ∈ ℂ, the set of constants

e = v                     (Literals)
  | e₁ e₂                 (Application)
  | n                     (Variables)
  | do o e                (Operation Invocations)
  | interpreter H: e      (Effect Interpreters)
  | handler H: e          (Effect Handlers)
  | shallow H: e          (Shallow Interpreters)
  | runner H: e           (Effect Runners)
  | fix H: e              (Effect Fixing)
v = c                     (Constants)
  | λ n. e                (Abstractions)
H = { (o → λ n. e), ... } (Interpretation Literals)
C = □                     (Empty Contexts)
  | C e                   (Function Contexts)
  | v C                   (Argument Contexts)
  | do o C                (Invocation Contexts)
  | interpreter H: C      (Interpreter Contexts)
  | handler H: C          (Handler Contexts)
  | shallow H: C          (Shallow Interpreter Contexts)
  | runner H: C           (Runner Contexts)
  | fix H: C              (Fix Contexts)

Functions and Constants
=======================

[Predefined Names]

reflect, fwd ∈ 𝕆

[Handled-By Relation]

o ~ H ⇔ ∃ e, (o → λ n. e)
o ≁ H ⇔ ¬(o ~ H)

[Interpretation Union (right-prioritizing dictionary union)]

{}                  ⨆ r = r
{(o → λ n. e), ...} ⨆ r = ({...} ⨆ r)                  if o ~ r
                          ({...} ⨆ r) ∪ {(o → λ n. e)} otherwise

[Context Interpretation]

handled(□)                = ∅
handled(C e)              = handled(C)
handled(v C)              = handled(C)
handled(do o C)           = handled(C)
handled(interpreter H: C) = H ⨆ handled(C)
handled(handler H: C)     = H ⨆ handled(C)
handled(shallow H: C)     = H ⨆ handled(C)
handled(runner H: C)      = H ⨆ handled(C)
handled(fix H: C)         = H ⨆ handled(C)

Semantics
=========

[β-reduction]

---------------------------
  (λ n. e) v ⇒ e[n ↦ v]

[In-Context]

   e₁ ⇒ e₂
---------------
 C[e₁] ⇒ C[e₂]

[Interpreters over Values]

----------------------
 interpreter H: v ⇒ v

[Interpreter Invocation]
              
    (o → λ n. e) ∈ H         o ≁ handled(C)
-------------------------------------------------
 interpreter H: C[do o v] ⇒ interpreter H: C[e[n ↦ v]]

[Shallow Interpreters over Values]

------------------
 shallow H: v ⇒ v

[Shallow Interpreter Invocation]

     (o → λ n. e) ∈ H    o ≁ handled(C)
--------------------------------------------
 shallow H: C[do o v] ⇒ C[e[n ↦ v]]

[Fix over Values]

--------------
 fix H: v ⇒ v

[Fix Invocation]

       (o → λ n. e) ∈ H         o ≁ handled(C)
------------------------------------------------------
 fix H: C[do o v] ⇒ fix H: C[interpreter H: e[n ↦ v]]]

[Handlers over Values]

------------------
 handler H: v ⇒ v 

[Outermost Handlers]

 (o → λ n. e) ∈ H    o ≁ handled(C₁)    o ≁ handled(C₂)
---------------------------------------------------------
 C₁[handler H: C₂[do o v]] ⇒ C₁[handler H: C₂[e[n ↦ v]]]

[Nested Handlers]

   (o → λ n₁. e₁) ∈ H    (o → λ n₂. e₂) ∈ handled(C₁)    o ≁ handled(C₂)
-------------------------------------------------------------------------------
 C₁[handler H: C₂[do o v]]
    ⇒
 C₁[handler H: C₂[shallow {(fwd → λn₂. e₂)}: e₁[n₁ ↦ v]]]

[Runners over Values]

-----------------
 runner H: v ⇒ v

[Outermost Runners]

 H₂ = handled(C₁), (o → λ n. e) ∈ H₁, o ≁ H₂, o ≁ handled(C₂)
--------------------------------------------------------------
 C₁[runner H₁: C₂[do o v]]
   ⇒
 C₁[runner H₁: C₂[interpreter H₂: e[n ↦ v]]]

[Nested Runners]

 H₂ = handled(C₁), (o → λ n₁. e₁) ∈ H₁, o ~ H₂, o ≁ handled(C₂)
-----------------------------------------------------------------------------
 C₁[runner H₁: C₂[do o v]]
     ⇒
 C₁[runner H₁:
     C₂[fix H₂:
         shallow {(reflect → λ n₂. interpreter H₂: do o n₂)}:
             e₁[n₁ ↦ v]
     ]
 ]
