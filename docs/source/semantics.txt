Notes
=====

Right now I'm trying to avoid having a global interpretation,
mainly because it makes equational reasoning much harder, though
it may just need to be that way.

Syntax
======

o âˆˆ ğ•†, the set of operations
n âˆˆ â„•, the set of names
c âˆˆ â„‚, the set of constants

e = v      (Literals)
  | eâ‚ eâ‚‚  (Application)
  | n      (Variables)
  | H â–  e  (Effect Interpreters)
  | H â†“ e  (Effect Handlers)
  | H â†¯ e  (Effect Runners)
  | !o     (Operation Invocations)
v = c      (Constants)
  | Î» n. e (Abstractions)
H = { (o â†’ e), ... } (Effect Sets)

Constants
=========

fwd, reflect âˆˆ ğ•†

Semantics
=========

[Î²-reduction]

    eâ‚ â‡’ Î» n. eâ‚‚
-------------------
 eâ‚ eâ‚ƒ â‡’ eâ‚‚[n â†¦ eâ‚ƒ]

[Interpreters over Values]

-----------
 H â–  v â‡’ v

[Interpreters over Applications]

---------------------------------
 H â–  (eâ‚ eâ‚‚) â‡’ H â–  ((H â–  eâ‚) (H â–  eâ‚‚))

[Interpreter Invocation]

   (o â†’ eâ‚) âˆˆ H
------------------
  H â–  !o â‡’ H â–  eâ‚

[Interpreter Composition]

----------------------------
 Hâ‚ â–  Hâ‚‚ â–  e â‡’ (Hâ‚ â— Hâ‚‚) â–  e

[Handler Composition]

-----------------------------
 Hâ‚ â–  Hâ‚‚ â†“ e â‡’ (Hâ‚ âŠ• Hâ‚‚) â–  e

[Runner Composition]

-----------------------------
 Hâ‚ â–  Hâ‚‚ â†¯ e â‡’ (Hâ‚ âŠ— Hâ‚‚) â–  e


Interpretation Combinators
==========================

domain(H) = { o | (o â†’ e) âˆˆ H }
range(H)  = { e | (o â†’ e) âˆˆ H }

[Interpreter Union]

Hâ‚ â— Hâ‚‚ = {
   if (o â†’ eâ‚) âˆˆ Hâ‚ then (o â†’ eâ‚) else 
   if (o â†’ eâ‚‚) âˆˆ Hâ‚‚ then (o â†’ eâ‚‚)
   | o âˆˆ domain(Hâ‚) âˆª domain(Hâ‚‚)
} âˆª Hâ‚ âˆª Hâ‚‚

[Coproduct]

Hâ‚ âŠ• Hâ‚‚ = {
   (o â†’ {(fwd â†’ eâ‚‚)} â–  eâ‚)
   | (o â†’ eâ‚) âˆˆ Hâ‚, (o â†’ eâ‚‚) âˆˆ Hâ‚‚
} â— Hâ‚ â— Hâ‚‚

[Reflection]

â†» H = { o â†’ H â–  e | (o â†’ e) âˆˆ H }

[Product]

Hâ‚ âŠ— Hâ‚‚ = {
   (o â†’ (â†» H) â–  (if (o â†’ eâ‚) âˆˆ Hâ‚
                 then {(reflect â†’ Hâ‚ â–  eâ‚)} â–  eâ‚‚
                 else eâ‚‚))
   | (o â†’ eâ‚‚) âˆˆ Hâ‚‚
}
